# PANORAMICA COMPLETA DEL PROGETTO SIGMA-NEX
# Sistema di Intelligenza Artificiale Autonomo per la Sopravvivenza Offline-First
# Analisi dettagliata di architettura, classi, funzioni e metodi

================================================================================
INFORMAZIONI GENERALI DEL PROGETTO
================================================================================

Nome Progetto: SIGMA-NEX
Versione: 0.3.1  
Autore: Sebastian Martin (rootedlab6@gmail.com)
Licenza: CC BY-NC 4.0
Descrizione: Agente cognitivo autonomo per la sopravvivenza offline-first in scenari estremi

Struttura del progetto:
- Linguaggio principale: Python 3.x
- Framework GUI: CustomTkinter
- Server API: FastAPI + Uvicorn
- Database vettoriale: FAISS per ricerca semantica
- Modelli NLP: SentenceTransformers, Transformers (Marian per traduzione)
- Architettura: Plugin-based con pattern Strategy

================================================================================
ARCHITETTURA MODULARE E COMPONENTI PRINCIPALI
================================================================================

Il progetto SIGMA-NEX è strutturato in modo modulare con i seguenti package principali:

📦 sigma_nex/
├── 🎯 __init__.py          - Package principale con metadata
├── ⚙️ cli.py               - Interfaccia Command Line  
├── 🔧 config.py            - Gestione configurazione centralizzata
├── 📊 data_loader.py       - Caricamento dati JSON/framework
├── 🌐 server.py            - Server API REST FastAPI
├── 📁 core/                - Core logic dell'agente
│   ├── 🧠 context.py       - Costruzione prompt e contesto
│   ├── 🔍 retriever.py     - Ricerca semantica FAISS
│   ├── 🏃 runner.py        - Engine esecuzione principale
│   └── 🌍 translate.py     - Sistema traduzione bidirezionale
├── 🖼️ gui/                 - Interfaccia grafica
│   └── 💻 main_gui.py      - GUI CustomTkinter
└── 🛡️ utils/              - Utilità e sicurezza
    ├── 🔒 security.py      - Crittografia e sicurezza
    └── ✅ validation.py    - Validazione input e sanitizzazione

================================================================================
MAPPATURA DETTAGLIATA CLASSI, FUNZIONI E METODI
================================================================================

## 1. MODULO CLI (cli.py)
================================================================================

### Funzioni Command Line:
- main(ctx, secure) -> None
  - Entry point principale CLI con supporto modalità sicura
  - Gestisce configurazione globale e context passing

- start(ctx) -> None  
  - Avvia agente in modalità REPL interattivo
  - Inizializza Runner con configurazione da context

- load_framework(path) -> None
  - Carica file Framework_SIGMA.json da path specificato
  - Utilizza DataLoader per conteggio moduli caricati

- self_check(ctx) -> None
  - Verifica disponibilità Ollama CLI e modelli
  - Esegue diagnostica sistema tramite Runner

- self_heal(ctx, file) -> None
  - Analizza e migliora codice Python specificato
  - Genera patch con suggerimenti tramite Runner

- server(ctx, host, port) -> None
  - Avvia server API REST su host:port specificati
  - Gestisce ImportError per dipendenze FastAPI mancanti

- gui() -> None
  - Lancia interfaccia grafica principale
  - Gestisce ImportError per CustomTkinter mancante

- install_config(uninstall) -> None
  - Installa/rimuove configurazione globale sistema
  - Gestisce percorsi Windows/Unix differenziati
  - Copia file di configurazione e dati in directory utente

## 2. CONFIGURAZIONE (config.py) 
================================================================================

### Classe SigmaConfig:
Sistema di configurazione centralizzato e path management

#### Metodi di inizializzazione:
- __init__(self, config_path: Optional[str] = None)
  - Inizializza config manager con auto-detection project root
  - Carica configurazione YAML con fallback graceful

- _find_project_root(self) -> Path
  - Algoritmo smart per trovare root progetto
  - Cerca config.yaml in directory gerarchiche
  - Supporta variabile ambiente SIGMA_NEX_ROOT

#### Proprietà di caricamento:
- config -> Dict[str, Any]
  - Property lazy-loading per configurazione YAML
  - Cache configurazione in memoria

- framework -> Dict[str, Any] 
  - Property per caricamento Framework_SIGMA.json
  - Gestione errori con fallback vuoto

#### Metodi di gestione path:
- get_path(self, path_type: str, default_relative: str = "") -> Path
  - Risolve path per tipi di risorse (models, data, logs, temp)
  - Supporta path assoluti e relativi alla project root

#### Metodi di configurazione:
- get(self, key: str, default: Any = None) -> Any
  - Accesso configurazione con dotted-key support (es. "model.temperature")
  - Valori default integrati per chiavi comuni

- set(self, key: str, value: Any) -> None
  - Impostazione valori configurazione con nested dict creation
  - Supporta dotted-key per strutture annidate

- save(self) -> None
  - Persistenza configurazione su disco con creazione directory

### Funzioni di compatibilità:
- get_config(config_path: Optional[str] = None) -> SigmaConfig
  - Singleton pattern per istanza configurazione globale
  - Re-inizializzazione se nuovo path fornito

- load_config(config_path: Optional[str] = None) -> Dict[str, Any]
  - Funzione legacy per compatibilità test esistenti
  - Caricamento diretto YAML con validazione system_prompt

## 3. DATA LOADER (data_loader.py)
================================================================================

### Classe DataLoader:
Responsabile caricamento moduli operativi da file JSON

#### Metodi principali:
- load(self, path: str) -> int
  - Carica file JSON contenente framework operativo
  - Restituisce numero moduli trovati in data["modules"]
  - Gestione errori con fallback zero
  - Output click.echo per conferma caricamento

### Funzione utilitaria:
- load_json_data(path: str) -> Dict[str, Any]
  - Caricamento JSON generico con gestione errori
  - Utilizzata da DataLoader e test suite

## 4. CORE ENGINE - RUNNER (core/runner.py)
================================================================================

### Classe Runner:
Engine di esecuzione principale con gestione memoria e sicurezza

#### Inizializzazione e configurazione:
- __init__(self, config, secure=False, max_history=None, model_name=None)
  - Inizializza runner con configurazione e parametri sicurezza
  - Gestione history con collections.deque per efficienza memoria
  - Auto-detection Ollama CLI availability
  - Inizializzazione metriche performance

#### Modalità interattiva:
- interactive(self) -> None
  - Avvia modalità REPL con prompt "σ>"
  - Gestisce comandi speciali: help, stats, clear, export, exit
  - Loop interattivo con gestione ValidationError e eccezioni

#### Processamento query:
- _process_query(self, query: str) -> str
  - Pipeline di processamento: sanitizzazione → traduzione → model call
  - Gestione cronologia conversazione con memory management
  - Integrazione sistema di traduzione bidirezionale

- process_query(self, query: str) -> Dict[str, Any]
  - Wrapper pubblico con timing e gestione errori
  - Restituisce response + processing_time o error

#### Comunicazione con modelli:
- _call_model(self, prompt: str) -> str
  - Comunicazione HTTP API con Ollama (localhost:11434)
  - Gestione timeout, connection errors, status codes
  - Preferenza HTTP API su CLI per performance

- _send_with_progress(self, prompt: str) -> str
  - Legacy method per GUI compatibility
  - Progress bar threading per operazioni lunghe
  - Fallback automatico HTTP se CLI non disponibile

#### Gestione file temporanei:
- register_temp_file(self, filepath: str) -> None
  - Registrazione file temporanei per cleanup
  
- _cleanup_temp_file(self, filepath: str) -> None
  - Rimozione sicura singolo file temporaneo

- cleanup_temp_files(self) -> None / _cleanup(self) -> None
  - Cleanup completo tutti i file temporanei registrati

#### Comandi speciali REPL:
- _show_help(self) -> None
  - Mostra help comandi disponibili

- _show_stats(self) -> None  
  - Statistiche performance: query processate, tempi, cronologia

- _clear_history(self) -> None
  - Cancellazione cronologia conversazione

- _export_history(self, command: str) -> None
  - Esportazione cronologia su file con validazione path

#### Diagnostica e auto-healing:
- self_check(self) -> None
  - Verifica disponibilità Ollama e modelli installati
  - Lista modelli disponibili tramite "ollama list"

- self_heal_file(self, file_path: str) -> str
  - Analisi e miglioramento file Python
  - Validazione sicurezza path, generazione patch
  - Salvataggio suggerimenti in file .patch

#### Gestione cronologia e performance:
- add_to_history(self, item: str) -> None
- get_history_context(self) -> list  
- clear_history(self) -> None
- get_performance_stats(self) -> Dict[str, Any]
  - Metodi pubblici per gestione cronologia e metriche

## 5. COSTRUZIONE CONTESTO (core/context.py)
================================================================================

### Funzione principale:
- build_prompt(system_prompt: str, history: list, query: str, retrieval_enabled: bool = True) -> str
  - Costruisce prompt finale unendo system prompt + knowledge + history + query
  - Integrazione retrieval FAISS per conoscenza operativa
  - Parsing moduli rilevanti con formato MODULO N: NOME/DESCRIZIONE
  - Gestione fallback per retrieval non disponibile

## 6. RICERCA SEMANTICA (core/retriever.py)
================================================================================

### Costanti e configurazione:
- DATA_PATH, INDEX_PATH, MAPPING_PATH, MODEL_PATH
  - Path per dati framework, indice FAISS, mappature, modelli

### Cache modelli globale:
- _model, model (backward compatibility per test)
  - Cache globale modello SentenceTransformer
  - Lazy loading per ottimizzazione memoria

### Funzioni di gestione modelli:
- _get_model() -> SentenceTransformer
  - Caricamento lazy modello "paraphrase-MiniLM-L6-v2"
  - Cache globale per evitare ricaricamenti
  - Fallback path management se modello non trovato

### Classe Retriever:
Sistema di ricerca semantica usando FAISS

#### Metodi principali:
- __init__(self, index_path: str, model_name: str)
  - Inizializzazione con path indice e nome modello
  - Creazione istanza SentenceTransformer

- search(self, query: str, k: int = 3) -> List[str]
  - Delega ricerca a search_moduli function
  - Interfaccia orientata agli oggetti per ricerca

### Funzioni di utility:
- get_moduli() -> List[dict]
  - Caricamento lista moduli da Framework_SIGMA.json
  - Gestione errori con ritorno lista vuota
  - Encoding UTF-8 per caratteri speciali

- build_index() -> None
  - Costruzione indice FAISS da moduli caricati
  - Estrazione testo da moduli, encoding vettoriale
  - Salvataggio indice e mappatura su disco
  - Gestione dipendenze opzionali (FAISS, SentenceTransformers)

- search_moduli(query: str, k: int = 3) -> List[str]
  - Ricerca semantica principale usando FAISS
  - Encoding query, search vettoriale, mapping risultati
  - Fallback graceful se FAISS non disponibile
  - Gestione errori con ritorno lista vuota

## 7. TRADUZIONE (core/translate.py)
================================================================================

### Gestione dipendenze e lazy loading:
- _check_transformers() -> bool
  - Verifica disponibilità transformers library
  - Import lazy MarianMTModel e MarianTokenizer
  - Cache risultato controllo per performance

- _get_model_paths() -> Dict[str, Path]
  - Risolve path modelli traduzione usando configurazione
  - Ritorna path per direzioni "it-en" e "en-it"

### Cache modelli thread-safe:
- _models: Dict[str, Tuple] con _lock: threading.Lock()
  - Cache thread-safe per modelli traduzione caricati
  - Evita ricaricamenti multipli in ambiente multi-thread

### Caricamento modelli:
- _load_model(direction: str) -> Optional[Tuple]
  - Caricamento thread-safe modelli MarianMT
  - Validazione path prima di cache access
  - Gestione errori con logging dettagliato

### Traduzione chunked per testi lunghi:
- _chunk_translate(text: str, tokenizer, model, max_tokens: int = 500) -> str
  - Suddivisione testo in chunk per gestione token limit
  - Split sentence-based con fallback character-based
  - Traduzione chunk parallela con gestione errori

### Funzioni di traduzione principali:
- translate_it_to_en(text: str) -> str
  - Traduzione Italiano → Inglese con gestione chunk
  - Fallback graceful se modello non disponibile

- translate_en_to_it(text: str) -> str  
  - Traduzione Inglese → Italiano con gestione chunk
  - Fallback graceful se modello non disponibile

### Utility functions:
- is_translation_available() -> bool
  - Verifica disponibilità sistema traduzione

- preload_models() -> None
  - Precaricamento modelli per performance migliori

## 8. SERVER API (server.py)
================================================================================

### Modelli Pydantic:
- SigmaRequest: Validazione request con question, history, user_id, chat_id, username
- SigmaResponse: Response format con response, processing_time, model_used  
- HealthResponse: Health check con status, version, uptime, requests_processed

### Classe SigmaServer:
Server FastAPI ottimizzato con supporto async e sicurezza

#### Inizializzazione:
- __init__(self, config_path: Optional[str] = None)
  - Setup FastAPI app con CORS middleware
  - Inizializzazione Runner, logging, blocklist, traduzione
  - Configurazione route e middleware sicurezza

#### Sistemi di sicurezza:
- _init_blocklist(self) -> None
  - Inizializzazione sistema blocklist utenti/chat
  - Cache blocklist con timeout 60 secondi

- _get_blocklist(self) -> Dict[str, List[str]]  
  - Caricamento blocklist con caching async
  - Thread-safe con asyncio.Lock()

- _is_blocked(self, user_id, chat_id) -> bool
  - Verifica blocco utenti/chat con fallback sicuro

#### Logging e monitoring:
- _init_logging(self) -> None
  - Setup logging su file sigma_api.log

- _log_request(self, data: Dict[str, Any]) -> None
  - Logging asincrono richieste con sanitizzazione dati

- _get_client_info(self, request: Request) -> Dict[str, str]
  - Estrazione info client: IP, hostname, user-agent

#### Comunicazione modelli:
- _call_ollama(self, payload: Dict[str, Any]) -> str
  - Chiamata asincrona API Ollama con gestione errori
  - Timeout management, status code handling
  - Limitazione lunghezza response

- _call_medical_model(self, prompt: str) -> Optional[str]
  - Chiamata modello medico specializzato "medllama2"
  - Fallback graceful se non disponibile

#### Enhancement medico:
- _init_medical_keywords(self) -> None
  - Inizializzazione keywords mediche italiane
  - Lista estesa termini medici, farmaci, procedure

- _is_medical_query(self, text: str) -> bool
  - Rilevamento query mediche tramite keyword matching

#### Route endpoints:
- / (GET): Health check con uptime e statistiche
- /ask (POST): Endpoint principale query SIGMA-NEX  
- /logs (GET): Accesso logs (solo localhost)
- /api/query (POST): Endpoint legacy per compatibilità

#### Startup e gestione:
- startup(self) -> None
  - Tasks asincroni avvio server (preload modelli)

- run(self, host, port, **kwargs) -> None
  - Avvio server Uvicorn con configurazione

## 9. INTERFACCIA GRAFICA (gui/main_gui.py)
================================================================================

### Funzioni di setup:
- set_project_root() -> None
  - Configurazione working directory e sys.path
  - Gestione ambiente frozen vs sviluppo

### Classe SigmaNexGUI:
Interfaccia grafica CustomTkinter per SIGMA-NEX

#### Inizializzazione GUI:
- __init__(self)
  - Setup finestra principale 760x560
  - Caricamento configurazione e inizializzazione Runner
  - Creazione elementi UI: entry, button, textbox, progress

#### Gestione comandi:
- process_command(self) -> None
  - Processamento comandi utente con threading
  - Aggiornamento UI asincrono

- run_background(self, func) -> None
  - Esecuzione funzioni in background thread
  - Gestione progress indicator con stop threading

#### Funzionalità integrate:
- run_selfcheck(self) -> None
  - Self-check Ollama tramite Runner

- run_load_framework(self) -> None
  - Caricamento framework tramite file dialog
  - Integrazione DataLoader con feedback UI

- run_clear_history(self) -> None  
  - Cancellazione cronologia Runner

- run_export_history(self) -> None
  - Esportazione cronologia con file dialog

### Funzioni di entry point:  
- main() -> bool
  - Entry point GUI con gestione ImportError
  - Ritorna True/False per status avvio

## 10. VALIDAZIONE E SICUREZZA (utils/validation.py)
================================================================================

### Eccezioni personalizzate:
- ValidationError(ValueError)
  - Eccezione custom per errori validazione

### Funzioni di sanitizzazione:
- sanitize_text_input(text: str, max_length: int = 10000) -> str
  - Sanitizzazione completa input testuali
  - Rimozione script tags, SQL injection, template injection
  - Filtering path traversal e caratteri controllo
  - HTML entity decoding

- sanitize_log_data(data: Dict[str, Any]) -> Dict[str, Any]
  - Sanitizzazione dati per logging sicuro
  - Rimozione/mascheramento informazioni sensibili

### Validazione percorsi:
- validate_file_path(file_path, base_directory=None, allowed_extensions=None) -> Path
  - Validazione sicura percorsi file
  - Prevenzione path traversal attacks
  - Controllo estensioni consentite
  - Validazione symbolic link per sicurezza

### Validazione input specifici:
- validate_prompt(prompt: str, max_length: int = 50000) -> str
  - Validazione prompt per modelli con limite lunghezza

- validate_user_id(user_id: Optional[int]) -> Optional[int]
  - Validazione ID utente con range checks

## 11. CRITTOGRAFIA (utils/security.py)  
================================================================================

### Funzioni di crittografia:
- derive_key(password: str) -> bytes
  - Derivazione chiave da password usando SHA256
  - Encoding base64 per compatibilità Fernet

- encrypt(data: bytes, password: str) -> bytes
  - Crittografia dati usando Fernet symmetric encryption

- decrypt(token: bytes, password: str) -> bytes  
  - Decrittografia token Fernet con password

================================================================================
DESIGN PATTERNS E ARCHITETTURA IMPLEMENTATI
================================================================================

## 1. Plugin Architecture:
- Struttura modulare per estensibilità
- Core separato da GUI/CLI/Server
- Lazy loading dipendenze pesanti

## 2. Strategy Pattern:
- Diversi processing strategy per contesti (medical, general, emergency)
- Intercambiabilità componenti traduzione/retrieval

## 3. Singleton Pattern:
- Configurazione centralizzata con get_config()
- Cache modelli globale per performance

## 4. Observer Pattern:
- Logging centralizzato eventi sistema
- Progress reporting per operazioni lunghe

## 5. Factory Pattern:
- Creazione dinamica componenti basata su configurazione
- Model loading condizionale su disponibilità

## 6. Facade Pattern:
- CLI come facade per core functionality
- API endpoint che nascondono complessità interna

================================================================================
FLUSSO OPERATIVO E INTERAZIONI TRA COMPONENTI
================================================================================

### Flusso Query Standard:
1. Input utente → Sanitizzazione (validation.py)
2. Traduzione IT→EN (translate.py) se necessario
3. Costruzione contesto con retrieval (context.py + retriever.py)
4. Chiamata modello tramite Runner → Ollama API
5. Traduzione EN→IT response se necessario
6. Aggiornamento cronologia e logging

### Flusso Ricerca Semantica:  
1. Query → Encoding vettoriale (SentenceTransformer)
2. Search FAISS index → Recupero indici simili
3. Mapping indici → Testi descrittivi da JSON
4. Integrazione risultati in prompt contestuale

### Flusso Configurazione:
1. Auto-detection project root → Caricamento config.yaml
2. Path resolution per risorse → Validazione esistenza
3. Framework loading → Parsing moduli operativi
4. Component initialization con dependency injection

================================================================================
GESTIONE ERRORI E RESILIENZA
================================================================================

### Livelli di Fallback:
1. **Dipendenze opzionali**: FAISS, transformers, customtkinter con fallback graceful
2. **Comunicazione modelli**: HTTP API → CLI → Mock response
3. **Traduzione**: Modelli locali → Passthrough originale
4. **Configurazione**: File YAML → Defaults hardcoded
5. **Ricerca semantica**: FAISS → Ricerca testuale semplice

### Gestione Errori Centralizzata:
- ValidationError per input non validi
- RuntimeError per problemi sistema/comunicazione  
- ImportError per dipendenze mancanti con messaggio utente
- Logging strutturato errori per debugging

================================================================================
PERFORMANCE E OTTIMIZZAZIONI
================================================================================

### Memory Management:
- collections.deque per cronologia con maxlen
- Lazy loading modelli pesanti
- Cache thread-safe con timeout

### I/O Optimization:
- Async file operations nel server
- Thread pool per operazioni blocking
- Progress indicators per UX

### Network Optimization:  
- Connection pooling implicito requests library
- Timeout configurabili per robustezza
- Response size limiting per memoria

================================================================================
TESTING E QUALITÀ CODICE
================================================================================

Il progetto include test suite estensiva con:
- Unit test realistici per ogni componente
- Integration test end-to-end
- Mock strategico per dipendenze esterne
- Coverage testing con obiettivo 95%
- Security testing con Bandit
- Performance benchmarking

### Struttura Test:
- tests/unit/ → Test unitari per ogni modulo
- Mock patterns per componenti esterni (Ollama, FAISS)
- Fixture realistiche per test data
- Parametrized testing per coverage completa

================================================================================
ESTENSIBILITÀ E SVILUPPO FUTURO
================================================================================

### Punti di Estensione:
1. **Nuovi modelli**: Interfaccia standardizzata Runner
2. **Plugin processing**: Strategy pattern per nuovi domini
3. **Datasource**: DataLoader estendibile per formati diversi
4. **UI alternative**: Core separato da interfacce
5. **API endpoints**: FastAPI router modulare

### Roadmap Tecnica:
- Supporto modelli LLaMA locali
- Plugin system formale con discovery
- Database persistence per cronologia
- Monitoring avanzato con metriche
- Container deployment con Docker

================================================================================
CONFIGURAZIONE E DEPLOYMENT
================================================================================

### File di Configurazione:
- config.yaml → Configurazione principale sistema
- Framework_SIGMA.json → Database moduli sopravvivenza
- requirements.txt/requirements-test.txt → Dipendenze Python

### Deployment Options:
1. **Standalone**: Installazione diretta con pip
2. **Global config**: Sistema configurazione utente multi-directory  
3. **Docker**: Container con volume mounting per dati
4. **CLI global**: Comando sigma globale con path management

### Environment Variables:
- SIGMA_NEX_ROOT → Override project root detection
- Debug/logging levels configurabili
- Model paths configurabili per deployment custom

================================================================================
CONCLUSIONI TECNICHE
================================================================================

SIGMA-NEX rappresenta un'architettura software robusta e modulare per un agente cognitivo specializzato in sopravvivenza. L'implementazione combina:

**Punti di forza tecnici:**
✅ Architettura modulare con separazione responsabilità
✅ Gestione errori robusta con fallback graceful  
✅ Performance ottimizzate con lazy loading e caching
✅ Sicurezza integrata con validazione input centralizzata
✅ Testabilità elevata con mock strategy intelligente
✅ Multi-interface (CLI/GUI/API) con core condiviso
✅ Offline-first design con dipendenze opzionali

**Innovazioni implementative:**
🚀 Plugin architecture per estensibilità
🚀 Ricerca semantica FAISS per knowledge retrieval
🚀 Sistema traduzione bidirezionale automatica
🚀 Medical enhancement con modelli specializzati
🚀 Configuration management centralizzato multi-environment
🚀 Thread-safe model caching per performance
🚀 Async FastAPI server con security middleware

Il progetto dimostra maturità architetturale e qualità ingegneristica elevata, rappresentando un esempio significativo di AI system engineering per applicazioni mission-critical.

================================================================================
FINE PANORAMICA TECNICA SIGMA-NEX v0.3.1
================================================================================